#!/usr/bin/env python
# coding=utf-8
'''
File: EmBCI/files/service/S01data-streaming.py
Author: Hankso
Web: http://github.com/hankso
Time: Fri 16 Nov 2018 13:14:50 CST
'''

# built-in
import os
import sys
import signal
import platform
import traceback
from threading import Thread, Event

# requirements.txt: necessary: pyzmq
import zmq

__dir__ = os.path.dirname(os.path.abspath(__file__))
__file__ = os.path.basename(__file__)

# in case embci is not installed to /usr/local/lib/pythonx.x yet
EMBCI_PATH = os.path.abspath(os.path.join(__dir__, '../../'))
if EMBCI_PATH not in sys.path:
    sys.path.append(EMBCI_PATH)

# from EMBCI_PATH
if platform.machine() in ['arm', 'aarch64']:
    from embci.io import ESP32_SPI_reader as Reader
else:
    from embci.io import Fake_data_generator as Reader
from embci.utils.ads1299_api import INPUT_SOURCE

DATA_CONTROL = ['start', 'pause', 'resume', 'close', 'restart']
LISTEN_PORT = 9997
TASK = '[S01data-streaming] '

HELP = help = '''
Data streaming process started by S01data-streaming script.
Streaming controller thread will listen on `tcp://localhost:{port}`,
with which users can change data capturing params at runtime by sending
commands to this controller powered by PyZMQ outside the process.
Commands syntax are listed below:
    CMD            \t\t[PARAM]
 1  sample_rate[sr]\t\t250 | 500 | 1000
 2  enable_bias[eb]\t\tTrue | False
 3  input_source[is]\t\t{inputs}
 4  reader_status[rs]\t\t{status}
 5  measure_impedance[mi]\tTrue | False

If `PARAM` is not provided, controller will return current value of `CMD`:
    >>> import zmq
    >>> c = zmq.Context()
    >>> q = c.socket(zmq.REQ)
    >>> q.connect('tcp://localhost:9997')
    >>> while 1:
            q.send(raw_input('console@S01:$ '))
            print(q.recv())
    console@S01:$ enable_bias
    True
    console@S01:$ enable_bias False
    console@S01:$ enable_bias
    False
'''.format(
    port=LISTEN_PORT,
    inputs=' | '.join(INPUT_SOURCE.keys()),
    status=' | '.join(DATA_CONTROL))

# defaults
sample_rate = 500
enable_bias = True
input_source = 'normal'
measure_impedance = False
reader_status = 'start'

s = zmq.Context().socket(zmq.REP)
s.bind('tcp://127.0.0.1:%d' % LISTEN_PORT)
poller = zmq.Poller()
poller.register(s, zmq.POLLIN)
flag_term = Event()


def set_param(cmd, param):
    try:
        if cmd in ['sample_rate', 'sr']:
            cmd = 'sample_rate'
            param = int(param)
            reader.set_sample_rate(param)
        elif cmd in ['enable_bias', 'eb']:
            cmd = 'enable_bias'
            param = (param.lower() == 'true')
            reader.enable_bias = param
        elif cmd in ['measure_impedance', 'mi']:
            cmd = 'measure_impedance'
            param = (param.lower() == 'true')
            reader.measure_impedance = param
        elif cmd in ['input_source', 'is']:
            cmd = 'input_source'
            if param not in INPUT_SOURCE.keys():
                param = input_source
            reader.set_input_source(param)
        elif cmd in ['reader_status', 'rs']:
            cmd = 'reader_status'
            if param not in DATA_CONTROL:
                param = reader_status
            getattr(reader, param)()
        elif cmd in ['exit', 'real_time_sample_rate']:
            return '{}: cannot set: Permission denied'.format(cmd)
        else:
            return '{}: command not found'.format(cmd)
    except:
        return ''.join(traceback.format_exception(*sys.exc_info()))
    globals()[cmd] = param
    return 'Set `{}` to `{}`.'.format(cmd, param)


def get_param(cmd):
    if cmd == 'real_time_sample_rate':
        return reader.real_time_sample_rate
    elif cmd in ['exit', 'quit', 'q']:
        exit()
    elif cmd in globals():
        return globals()[cmd]
    else:
        return '{}: command not found'.format(cmd)


def repl():
    print(TASK + 'Listening on tcp://localhost:%d' % LISTEN_PORT)
    while not flag_term.isSet():
        try:
            if not poller.poll(timeout=1000):
                continue
            msg = s.recv().split()
            # TODO: try use argparse lib
            if len(msg) == 2:
                ret = set_param(*msg)
                s.send(str(ret))
            elif len(msg) == 1:
                ret = get_param(msg[0])
                s.send(str(ret))
            else:
                s.send('Invalid input: {}'.format(msg))
        except zmq.ZMQError:
            print(TASK + 'zmq socket error')
        except:
            traceback.print_exc()
    print(TASK + 'Controller thread terminated.')


def exit(*a, **k):
    flag_term.set()
    s.close()
    reader.close()
    print(TASK + 'Quit.')


if __name__ == '__main__':
    signal.signal(signal.SIGTERM, exit)

    print('[S01data-streaming] Start streaming.')
    reader = Reader(sample_rate, sample_time=1,
                    n_channel=8, send_to_pylsl=True)

    print(HELP)

    # let reader occupy main thread
    Thread(target=repl).start()
    reader.start(method='block')

    # or let REPL occupy main thread
    #  repl()
    #  reader.start(method='thread')
