#!/usr/bin/env python
# coding=utf-8
'''
File: EmBCI/files/service/S01data-streaming.py
Author: Hankso
Web: http://github.com/hankso
Time: Fri 16 Nov 2018 13:14:50 CST
'''

# built-in
import os
import sys
import signal
import platform
import traceback
from threading import Thread, Event

# requirements.txt: necessary: pyzmq
import zmq

__dir__ = os.path.dirname(os.path.abspath(__file__))
__file__ = os.path.basename(__file__)
EMBCI_PATH = os.path.abspath(os.path.join(__dir__, '../../'))
if EMBCI_PATH not in sys.path:
    sys.path.append(EMBCI_PATH)

# from EMBCI_PATH
if platform.machine() in ['arm', 'aarch64']:
    from embci.io import ESP32_SPI_reader as Reader
else:
    from embci.io import Fake_data_generator as Reader
from embci.utils.ads1299_api import INPUT_SOURCE

DATA_CONTROL = ['start', 'pause', 'resume', 'close', 'restart']
LISTEN_PORT = 9997

help = '''
Data streaming process started by S01data-streaming script.
Streaming controller thread will listen on `tcp://localhost:{port}`,
with which users can change data capturing params at runtime by sending
commands to this controller powered by PyZMQ outside the process.
Commands syntax are listed below:
    CMD            \t\t[PARAM]
 1  sample_rate[sr]\t\t250 | 500 | 1000
 2  enable_bias[eb]\t\tTrue | False
 3  input_source[is]\t\t{inputs}
 4  reader_status[rs]\t\t{status}
 5  measure_impedance[mi]\tTrue | False

If `PARAM` is not provided, controller will return current value of `CMD`:
    >>> import zmq
    >>> c = zmq.Context()
    >>> q = c.socket(zmq.REQ)
    >>> q.connect('tcp://localhost:9997')
    >>> q.send('enable_bias')
    True
    >>> q.send('enable_bias False')
'''.format(
    port=LISTEN_PORT,
    inputs=' | '.join(INPUT_SOURCE.keys()),
    status=' | '.join(DATA_CONTROL))

sample_rate = 500
enable_bias = True
input_source = 'normal'
measure_impedance = False
reader_status = 'start'

twine = zmq.Context()
s = twine.socket(zmq.REP)
s.bind('tcp://127.0.0.1:%d' % LISTEN_PORT)
poller = zmq.Poller()
poller.register(s, zmq.POLLIN)
flag_term = Event()


def control():
    print('[S01data-streaming] Listening on tcp://localhost:%d' % LISTEN_PORT)
    while not flag_term.isSet():
        try:
            if not poller.poll(timeout=1000):
                continue
            msg = s.recv().split()
            if len(msg) == 2:
                cmd, param = msg
                if cmd in ['sample_rate', 'sr']:
                    param = int(param)
                    reader.set_sample_rate(param)
                elif cmd in ['enable_bias', 'eb']:
                    param = (param.lower() == 'true')
                    reader.enable_bias = param
                elif cmd in ['measure_impedance', 'mi']:
                    param = (param.lower() == 'true')
                    reader.measure_impedance = param
                elif cmd in ['input_source', 'is']:
                    if param not in INPUT_SOURCE.keys():
                        param = input_source
                    reader.set_input_source(param)
                elif cmd in ['reader_status', 'rs']:
                    if param not in DATA_CONTROL:
                        param = reader_status
                    getattr(reader, param)()
                globals()[cmd] = param
                s.send('Set `{}` to `{}`.'.format(cmd, param))
            elif len(msg) == 1:
                if msg[0] in globals():
                    s.send(str(globals()[msg[0]]))
                elif msg[0] == 'real_time_sample_rate':
                    s.send(str(reader.real_time_sample_rate))
                else:
                    s.send('Invalid command: {}'.format(msg))
            else:
                s.send('Invalid command: {}'.format(msg))
        except:
            traceback.print_exc()
    print('[S01data-streaming] Controller thread terminated.')


def exit(*a):
    flag_term.set()
    s.close()
    reader.close()
    print('[S01data-streaming] Quit.')

signal.signal(signal.SIGTERM, exit)

reader = Reader(sample_rate, sample_time=1, n_channel=8, send_to_pylsl=True)
thread = Thread(target=control)

print('[S01data-streaming] Start streaming.')
thread.start()
reader.start(method='block')
#  reader.start(method='thread')
