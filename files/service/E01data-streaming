#!/usr/bin/env python
# coding=utf-8
'''
File: EmBCI/files/service/S01data-streaming.py
Author: Hankso
Web: http://github.com/hankso
Time: Fri 16 Nov 2018 13:14:50 CST
'''
from __future__ import print_function

# built-in
import os
import sys
import time
import signal
import platform
import traceback
import threading

# requirements.txt: necessary: pyzmq
import zmq

__dir__ = os.path.dirname(os.path.abspath(__file__))
__file__ = os.path.basename(__file__)

# in case embci is not installed to /usr/local/lib/pythonx.x yet
EMBCI_PATH = os.path.abspath(os.path.join(__dir__, '../../'))
if EMBCI_PATH not in sys.path:
    sys.path.append(EMBCI_PATH)

try:
    import argparse
    # argparse is maintained as a separate package now
    # built-in argparse is provided >= 2.7
    _ = argparse.__version__.split('.')
    if len(_) < 3 or _[1] < 4:
        # argparse >= 1.4.0
        raise ImportError
except ImportError:
    from embci.utils import argparse as argparse

if platform.machine() in ['arm', 'aarch64']:
    from embci.io import ESP32_SPI_reader as Reader
else:
    from embci.io import Fake_data_generator as Reader
from embci.utils.ads1299_api import INPUT_SOURCES


STREAM_CONTROLS = ['start', 'pause', 'resume', 'close', 'restart']
LISTEN_PORT = 9997
TASK = '[{}] '.format(__file__)
FLAG = threading.Event()
signal.signal(signal.SIGTERM, lambda *a, **k: FLAG.set())

HELP = '''
Task data-streaming started by {filename} script in EmBCI. Streaming
controller interface will listen on `tcp://localhost:{port}`, from
which users can set data capturing params at runtime. One can send
commands to the controller powered by PyZMQ from other processes.
'''.format(filename=__file__, port=LISTEN_PORT)

EPILOG = '''
Examples:
    >>> import zmq
    >>> c = zmq.Context()
    >>> q = c.socket(zmq.REQ)
    >>> q.connect('tcp://localhost:9997')
    >>> while 1:
            q.send(raw_input('console@E01:$ '))
            print(q.recv())
    console@E01:$ enable_bias
    True
    console@E01:$ enable_bias False
    console@E01:$ enable_bias
    False

See `<command> -h` for more information on each command.
'''

# Defaults
sample_rate = 500
bias_output = True
input_source = 'normal'
measure_impedance = False
stream_control = 'start'


def summary(args):
    ret = ''
    ret += 'Realtime sample_rate: {}'.format(reader.real_time_sample_rate)
    ret += 'TODO: summary contain version info'
    return ret


def _subcommand(args):
    if args.param is not None:
        func = globals()['_set_' + args.subcmd]
        try:
            func(args.param)
        except:
            return ''.join(traceback.format_exception(*sys.exc_info()))
        globals()[args.subcmd] = args.param
        return 'Set `{subcmd}` to `{param}`'.format(**vars(args))
    else:
        return globals()[args.subcmd]


def _set_sample_rate(param):
    '''TODO: doc here'''
    reader.set_sample_rate(param)


def _set_bias_output(param):
    reader.enable_bias = param


def _set_input_source(param):
    reader.set_input_source(param)


def _set_stream_control(param):
    getattr(reader, param)()


def _set_measure_impedance(param):
    reader.measure_impedance = param


def _str_bool(v):
    t = str(v).title()
    if t == 'True':
        return True
    if t == 'False':
        return False
    if t == 'None':
        return None
    raise ValueError('Invalid boolean value: {}'.format(v))


def init_parser():
    parser = argparse.ArgumentParser(
        prog=__file__, formatter_class=argparse.RawDescriptionHelpFormatter,
        description=HELP, add_help=False, usage='<command> [-h] [param]',
        epilog=EPILOG,
    )
    subparsers = parser.add_subparsers(
        prog='', title='Support commands are', metavar='')

    # Command: summary
    subparsers.add_parser(
        'summary', aliases=['info'], help='summary of current stream status'
    ).set_defaults(func=summary)

    # Command: help
    subparsers.add_parser(
        'help', aliases=['h'], help='show this help message and exit'
    ).set_defaults(func=lambda args: parser.format_help())

    # Command: exit
    subparsers.add_parser(
        'exit', aliases=['quit'], help='terminate this task!!!'
    ).set_defaults(func=lambda args: FLAG.set())

    # Command: sample rate
    sparser = subparsers.add_parser(
        'sample_rate', aliases=['rate'], epilog=_set_sample_rate.__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        help='data stream sample rate'
    )
    sparser.add_argument('param', nargs='?', choices=[250, 500, 1000],
                         type=int)
    sparser.set_defaults(func=_subcommand, subcmd='sample_rate')

    # Command: bias output
    sparser = subparsers.add_parser(
        'bias_output', aliases=['bias'], epilog=_set_bias_output.__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        help='Generate signal on BIAS'
    )
    sparser.add_argument('param', nargs='?', type=_str_bool)
    sparser.set_defaults(func=_subcommand, subcmd='bias_output')

    # Command: input source
    sparser = subparsers.add_parser(
        'input_source', aliases=['input'], epilog=_set_input_source.__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        help='Select ADS1299 input source'
    )
    sparser.add_argument('param', nargs='?', choices=INPUT_SOURCES.keys())
    sparser.set_defaults(func=_subcommand, subcmd='input_source')

    # Command: stream control
    sparser = subparsers.add_parser(
        'stream_control', aliases=['data'], epilog=_set_stream_control.__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        help='Control data stream status'
    )
    sparser.add_argument('param', nargs='?', choices=STREAM_CONTROLS)
    sparser.set_defaults(func=_subcommand, subcmd='stream_control')

    # Command: measure impedance
    sparser = subparsers.add_parser(
        'measure_impedance', aliases=['impe'],
        epilog=_set_measure_impedance.__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        help='Measure impedance of channels'
    )
    sparser.add_argument('param', nargs='?', type=_str_bool)
    sparser.set_defaults(func=_subcommand, subcmd='measure_impedance')

    return parser


class _Box:
    box = []

    def write(self, msg):
        self.box.append(str(msg))

    def flush(self):
        pass

    def pop(self):
        box, self.box = self.box, []
        return ''.join(box)


def repl(flag_term, s):
    print(TASK + 'Listening on tcp://localhost:%d' % LISTEN_PORT)
    parser = init_parser()
    poller = zmq.Poller()
    poller.register(s, zmq.POLLIN)
    time.sleep(0.5)
    # parser will print error & help info to sys.stderr & sys.stdout
    # so redirect them to socket.send
    stderr, stdout = sys.stderr, sys.stdout
    msg_box = sys.stderr = sys.stdout = _Box()
    while not flag_term.isSet():
        try:
            # waiting for command
            if not poller.poll(timeout=500):
                continue
            cmd = map(lambda x: x.strip(), s.recv().split())

            # parse commands
            ret = ''
            try:
                args = parser.parse_args(cmd)
            except SystemExit:
                # handle parse error
                if cmd:
                    ret = msg_box.pop()
            else:
                # execute command
                ret = args.func(args)

            # return result of command
            if ret is None:
                s.close()
                break
            s.send(str(ret) + '\n')
        except zmq.ZMQError:
            print(TASK + 'zmq socket error', file=stdout)
        except:
            traceback.print_exc(file=stdout)
    sys.stderr, sys.stdout = stderr, stdout
    time.sleep(0.5)
    reader.close()
    s.close()
    print(TASK + 'Controller thread terminated.')


if __name__ == '__main__':
    reply = zmq.Context().socket(zmq.REP)
    reply.bind('tcp://127.0.0.1:%d' % LISTEN_PORT)

    reader = Reader(sample_rate, sample_time=1,
                    n_channel=8, send_to_pylsl=True)

    print(TASK + 'Start streaming.')
    print(HELP + EPILOG)
    print(TASK + 'Starting {}'.format(reader))

    #
    # let reader occupy main thread
    #
    threading.Thread(
        target=repl, args=(FLAG, reply)).start()
    reader.start(method='block')

    #
    # or let REPL occupy main thread
    #
    #  reader.start(method='thread')
    #  repl(FLAG, reply)
