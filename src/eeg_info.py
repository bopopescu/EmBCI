#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Wed Nov 22 13:45:05 2017

@author: hank
"""
import numpy as np

class EEG_Info(object):
    '''
    I am learning how to handle EEG data, which can be collected by varieties 
    of hardwares such as Mindset(Neurosky) and Epoc(Emotiv), etc.
    
    This class is used for extracting features from input time series data.
    
    Input data usually be buffered with a shape as:
        n_channel x window_size(sample_rate * sample_time) 
    '''
    def __init__(self):
        pass
    
    def check_shape(func):
        def wrapper(self, X):
            if type(X) is not np.ndarray:
                X = np.array(X)
                
            # simple 1D time series.
            # Input: windowsize
            if len(X.shape) == 1:
                return func(self, X.reshape(1, -1))
            
            # 2D array
            # Input: n_channel x window_size
            elif len(X.shape) == 2:
                return func(self, X)
            
            # 3D array
            # Input: n_sample x n_channel x window_size
            elif len(X.shape) == 3:
                return np.array([func(self, sample) for sample in X])
            
            # 3D+
            # Input: ... x n_sample x n_channel x window_size
            else:
                raise RuntimeError(('Input data shape {} is not supported.\n'
                                    'Please offer (n_channel x window_size) '
                                    '2D data or (n_sample x n_channel x '
                                    'window_size) 3D data.').format(X.shape))
        return wrapper

    @check_shape
    def average(self, X):
        '''
        The most simple feature: average of each channel
        '''
        shape = X.shape
        return np.average(X, axis=-1).reshape(shape[:-1] + (1, ))
    
    @check_shape
    def variance(self, X):
        '''
        Calculate variance along last axis
        
        Returns
        -------
        average( ( X[i] - average(X[i]) )**2 )
        '''
        shape = X.shape
        return np.var(X, axis=-1).reshape(shape[:-1] + (1, ))
    
    @check_shape
    def skewness(self, X):
        '''
        Skewness's definition from wiki:
            In probability theory and statistics, skewness is a measure of the 
            asymmetry of the probability distribution of a real-valued random 
            variable about its mean. The skewness value can be positive or 
            negative, or undefined.
        '''
        return (self.average((X-self.average(X))**3) / 
                self.variance(X)**3)
    
    @check_shape
    def kurtosis(self, X):
        '''
        Kurtosis's definition from wiki:
            In probability theory and statistics, kurtosis is a measure of the 
            "tailedness" of the probability distribution of a real-valued 
            random variable.
        '''
        return (self.average((X-self.average(X))**4) /
                self.variance(X)**2) - 3
                
    @check_shape
    def covariance(self, X):
        '''
        Covariance shows the level of which two random variables vary together.
        Here it represent how much two channel time-series EEG data have 
        similar changing trend. This might be useful when to handle
        Motion Imaginary EEG data where FP3 and FP4 series vary 
        
        Input shape:  X n_channel x window_size
        Output shape: C n_channel x n_channel
        Meaning:      C[i, j] = similar level of i_channel and j_channel
                      C[i, i] = similar level of i_channel itself
        '''
        return np.cov(X)

    @check_shape
    def freq_spectrum(self, X):
        '''
        Realtime frequency spectrum is generated by FFT(FastFourierTransform)
        And the results (freq-amp 2-D array) can be combined with time 
        infomation to generate an image, which is freq-time-amp 3-D array of 
        gray image exactly.
        '''
        pass

    @check_shape
    def autocorrelation(self, X):
        pass

    @check_shape
    def power_spectrum(self, X, sample_rate, method = 2):
        '''
        There are two kinds of defination of power spectrum(PS hereafter).
        1. PS = fft(autocorrelation(X))
           This is Winner-Khintchine defination
        2. PS = abs(fft(X))**2 / sample_time
           It is known that
                'P = W / S'
           (power equals to energy divided by time duration),
           and 'abs(fft(X))**2' is known as energy spectrum.
           'average_energy_flow_density = 1/2 * p * (A**2) * (w**2)'
           
        Parameters
        ----------
        X: array
            time series signal.
        sample_rate: int|float
            at least one of sample_rate and time should be given
        time: int|float
            seconds of the data. There is equation: len(X)=sample_rate*time
        
        Returns
        -------
        freq, power
        '''
        if method == 1:
            pass
        
        elif method == 2:
            sample_time = len(X) / sample_rate
            freq, amp = self.fft(X, sample_rate)
            return freq, amp**2/sample_time
        
    @check_shape
    def fft(self, X, sample_rate, time = None, freq_max = None):
        '''
        People use FT(Fourier Transform) to extract frequency domain
        info from time domain data in mathmatic questions. But when
        processing signals, DFT(Discret Fourier Transform) is a more
        practice way for computer calculation. And FFT(Fast discret
        Fourier Transform) is much more commonly used because it is 
        better at handling time-varying signals(you can add windows).
        
        There are four steps to get useful result of fft:
            1. raw = np.fft.fft(X), here raw is a complex ndarray
            2. amp = np.abs(raw[:num/2]), remove latter half of raw 
               and convert rest data into real number. 
               Result of fft is symmetric in the real part.
            3. samples = len(X) and raw /= samples
            4. Remove Nyquist point, that is: 
               if samples is odd number, amp*=2 except first point(freq=0)
               if samples is even number, amp*=2 except first and last points
        
        Attention: samples(sample_rate * time) should bigger than 
        twice of the max frequence you insterested in, i.e. time
        should longer than 1 second.
        
        Returns
        -------
        freq: np.linspace(0, sample_rate/2, length/2)
        amp:  np.ndarray, length/2
        '''
        length = len(X)
        amp = 2 * abs(np.fft.rfft(X)) / float(length)
        amp[0] /= 2
        if length % 2:
            amp[-1] /= 2
        freq= np.arange(0, sample_rate/2, len(amp))
        return freq, amp

    @check_shape
    def wavelet(self, X):
        pass
    
    @check_shape
    def sync_like(self, X):
        '''
        Sychronization likelihood is the method to abstract a state vector
        from a time-series data. This vector is distinguishable in state space,
        thus representing current state(raw data pattern).
        In a time interval, if state vectors of each frequency ranges (α|β|γ..)
        of each channels are similar, we can say sync_level of this people is 
        high at present and vice versa. It has been discovered that many kinds 
        of nervous diseases are related to out-sync of brain activities, such 
        as Alzheimer's Disease. By comparing state vector we can tell how 
        synchronous the subject's brain is.
        '''
        pass