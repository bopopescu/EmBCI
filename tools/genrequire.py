#!/usr/bin/env python3
# coding=utf-8
#
# File: EmBCI/tools/genrequire.py
# Authors: Hank <hankso1106@gmail.com>
# Create: 2019-10-14 05:43:04

# built-in
from __future__ import absolute_import, division, print_function
import os
import sys
import time
import logging
import argparse
import subprocess
from functools import reduce

HELP = '''
This script will extract magic string of requirements.txt from each python
source files found in a directory, and write modules into requirements.txt.
Modules can be sorted into different classes, such as `built-in`, `necessary`,
`replaceable` or `optional` etc. Line break is NOT allowed, multiple classes
in one line as well.
'''

EXAMPLE = '''
Magic string example:

# requirements.txt: aaa, bbb, ccc
# requirements.txt: foo: bar1, bar2
# requirements.txt: foo: bar3
# requirements.txt: optional: numpy, scipy

Usage example:
    genrequire ./ -v
    genrequire src/ utils/ tools/ -o requirements.txt
'''

MAGICSTRING = 'requirements.txt:'
logging.basicConfig(format='%(message)s', level=logging.INFO)
__file__ = os.path.abspath(__file__)


class Module(str):
    def __new__(cls, name, src, type=None):
        obj = str.__new__(cls, name)
        obj.name = name
        obj.srcfile = src
        obj.type = type
        return obj

    def __str__(self):
        return '<module {}:{type} @ {srcfile}>'.format(
            repr(self), **self.__dict__)


def python_filter(filename):
    '''
    Check whether file is python script by linux/unix command `file`
    '''
    mime = subprocess.check_output(['file', '-i', filename]).decode('ascii')
    return 'text/x-python' in mime
    #  return 'Python script' in subprocess.check_output(['file', filename])


def scandir(dir, cond=lambda x: x.endswith('.py'), indent=0):
    logging.debug('│   ' * max(0, (indent - 1)) +
                  (indent != 0) * '├── ' +
                  os.path.basename(dir))
    dir = os.path.abspath(dir)
    if os.path.isfile(dir):
        return [dir]
    srcfiles = []
    lst = sorted(os.listdir(dir))
    while lst:
        file = lst.pop(0)
        filename = os.path.join(dir, file)
        if filename.endswith(__file__):
            continue
        if os.path.isdir(filename):
            srcfiles += scandir(filename, indent=indent+1)
        elif os.path.isfile(filename):
            if cond(filename):
                srcfiles.append(filename)
                log = ' selected'
                time.sleep(0.01)
            elif filename.endswith('pyc'):
                continue
            else:
                log = ' skip'
            logging.debug(('│   ' if len(lst) else '│   ') * indent +
                          ('├── ' if len(lst) else '└── ') + file + log)
    return srcfiles


def extmod(file):
    msg = 'extract from {}: '.format(file)
    modules = []
    with open(file, 'r') as f:
        for line in [_ for _ in f if _.startswith('#') and MAGICSTRING in _]:
            line = line[line.index(MAGICSTRING) + len(MAGICSTRING):].strip()
            if ':' in line:
                i = line.index(':')
                c, line = line[:i].strip(), line[i+1:].strip()
            else:
                c = None
            ms = [Module(m.strip(), file, type=c) for m in line.split(',')]
            if len(ms):
                modules += ms
                msg += ' '.join(ms) + ' '
    if len(modules):
        logging.debug(msg.strip())
        time.sleep(0.05)
    return modules


def sortmod(modules):
    classes = {'_conflict': {}}
    while modules:
        m = modules.pop()
        for sm in [_ for _ in modules if m == _]:
            modules.remove(sm)
            if m.type != sm.type:
                if m not in classes['_conflict']:
                    classes['_conflict'][m] = []
                classes['_conflict'][m].append(sm)
        if m in classes['_conflict']:
            classes['_conflict'][m].append(m)
        else:
            if m.type not in classes:
                classes[m.type] = []
            classes[m.type].append(m)
    return classes


def genrequire(dirs, output):
    srcfiles = []
    for d in dirs:
        if os.path.exists(d) and os.path.isdir(d):
            srcfiles += scandir(d, cond=python_filter)

    logging.debug('\n' + '=' * 80 + '\n')

    modules = reduce(
        lambda f1, f2:
            (f1 + extmod(f2)) if isinstance(f1, list) else
            (extmod(f1) + extmod(f2)),
        srcfiles, [])

    if not modules:
        logging.warning('No modules found! Terminated.')
        sys.exit(1)

    logging.debug('\n' + '=' * 80 + '\n')

    classes = sortmod(modules)

    header = (
        '#\n# EmBCI Python module requirements.txt.\n'
        '#\n# Automatically generated file.\n'
        '#\n# DO NOT EDIT THIS FILE -- changes will be overwritten.\n'
        '#\n')

    body = '\n'.join(classes.pop(None, [])) + '\n\n'

    conflicts = ''
    if classes['_conflict']:
        conflicts += '# [conflicts]\n# You may manually solve them.\n\n'
        conflicts += '\n\n'.join([
            '\n\n'.join([
                '# From {}\n# [{}]\n'.format(m.srcfile, m.type) + m
                for m in lst])
            for lst in classes['_conflict'].values()])
        conflicts += '\n\n'
    classes.pop('_conflict')

    optional = ''
    if 'optional' in classes:
        optional += '# [optional]\n'
        optional += '\n'.join(sorted(classes.pop('optional')))
        optional += '\n\n'

    for c in sorted(classes):
        body += '# [{}]\n'.format(c)
        body += '\n'.join(sorted(classes[c]))
        body += '\n\n'

    if isinstance(output, str):
        path, filename = os.path.split(output)
        fn, ext = os.path.splitext(filename)
        extra = os.path.join(path, fn + '-dev' + ext)
        if os.path.exists(output):
            os.rename(output, output + '.old')
        if os.path.exists(extra):
            os.rename(extra, extra + '.old')
        output = open(output, 'w')
        extra = open(extra, 'w')

    logging.debug('Writing requirements to `%s`\n' % output)
    print(header + body + conflicts, file=output)
    if 'extra' in locals():
        print(header + body + conflicts + optional, file=extra)
        extra.close()
    else:
        print(optional, file=output)
        output.flush()
    logging.debug('\n' + '=' * 80 + '\n')
    logging.info('Generation of requirements done.')
    logging.debug('\n' + '=' * 80)


class HelpArgumentParser(argparse.ArgumentParser):
    def error(self, message):
        # argparse.ArgumentParser.error
        #  self.print_usage(_sys.stderr)
        #  self.exit(2, _('%s: error: %s\n') % (self.prog, message))
        message = message + '\n\n' + self.format_help()
        self.exit(2, '%s: error: %s\n' % (self.prog, message))


def main(arg):
    parser = HelpArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=HELP, epilog=EXAMPLE)
    parser.add_argument('dir', nargs='+',
                        help='directory[s] to scan for python source files')
    parser.add_argument('-o', '--output', default=sys.stdout,
                        help='output filename, default stdout')
    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help='be more verbose')
    args = parser.parse_args(arg)

    if args.verbose:
        logging.root.setLevel(logging.DEBUG)

    genrequire(args.dir, args.output)


if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
